<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Lacing War - Online Multiplayer</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* ç¹¼æ‰¿ä¹‹å‰çš„å„ªè³ª UI ... */
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #1a1a1a; color: white; margin: 0; min-height: 100vh; overflow-x: hidden; }
        #lobby { background: #333; padding: 25px; border-radius: 12px; margin-top: 30px; width: 450px; text-align: center; border: 1px solid #555; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .connection-step { margin: 15px 0; padding: 15px; background: #222; border-radius: 8px; }
        input { padding: 10px; border-radius: 5px; border: 1px solid #555; width: 220px; background: #000; color: #00ff00; font-family: monospace; font-size: 1.1em; }
        button { padding: 10px 20px; cursor: pointer; background: #27ae60; color: white; border: none; border-radius: 5px; font-weight: bold; transition: 0.2s; }
        button:hover { background: #2ecc71; }
        #game-container { display: none; flex-direction: column; align-items: center; padding-bottom: 50px; }
        #game-info { margin: 20px; text-align: center; background: #333; padding: 20px; border-radius: 15px; border: 1px solid #555; width: 460px; }
        .score-board { display: flex; gap: 60px; font-size: 1.6em; margin-top: 15px; justify-content: center; }
        .score-box { position: relative; display: flex; flex-direction: column; align-items: center; width: 130px; }
        .crown { font-size: 30px; position: absolute; top: -38px; display: none; animation: bounce 1s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        #board { display: grid; grid-template-columns: repeat(15, 30px); gap: 1px; background: #444; border: 5px solid #000; }
        .cell { width: 30px; height: 30px; background: #2c2c2c; display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; }
        .cell.disputed { background: #444; box-shadow: inset 0 0 8px #000; }
        .piece { width: 22px; height: 22px; border-radius: 50%; z-index: 10; border: 2px solid rgba(255,255,255,0.3); }
        .piece.p1 { background: #ff4757; box-shadow: 0 0 15px #ff4757; }
        .piece.p2 { background: #2e86de; box-shadow: 0 0 15px #2e86de; }
        .line { position: absolute; z-index: 1; opacity: 0.8; }
        .line.v { width: 4px; height: 100%; }
        .line.h { height: 4px; width: 100%; }
        .line.p1 { background: #ff4757; }
        .line.p2 { background: #2e86de; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(8px); }
        #result-card { background: #222; padding: 40px; border-radius: 20px; border: 3px solid #f1c40f; text-align: center; }
        #turn-display { font-size: 1.2em; color: #f1c40f; font-weight: bold; }
        #status-msg { font-size: 0.9em; color: #00ff00; margin-top: 10px; font-family: monospace; }
        #error-log { font-size: 0.8em; color: #ff4757; margin-top: 10px; display: none; }
    </style>
</head>
<body>

<div id="lobby">
    <h2 style="color: #f1c40f;">Lacing War</h2>
    <div class="connection-step">
        <div style="margin-bottom: 5px;">æ‚¨çš„é€£ç·š ID</div>
        <b id="my-id" style="font-size: 1.2em; color: #fff;">åˆå§‹åŒ–ä¸­...</b><br>
        <button onclick="copyMyID()" style="margin-top: 10px; background: #444;">è¤‡è£½ ID çµ¦å°æ‰‹</button>
    </div>
    <div class="connection-step">
        <input type="text" id="peer-id-input" placeholder="è²¼ä¸Šå°æ‰‹çš„ ID">
        <button id="connect-btn" onclick="connectToPeer()">é€²å…¥æˆ¿é–“</button>
    </div>
    <div id="status-msg">æ­£åœ¨å°‹æ‰¾ PeerJS ç¯€é»...</div>
    <div id="error-log"></div>
</div>

<div id="game-container">
    <div id="game-info">
        <div id="turn-display">åŒæ­¥ä¸­...</div>
        <div class="score-board">
            <div class="score-box">
                <div id="crown-p1" class="crown">ğŸ‘‘</div>
                <div class="player-label" style="color: #ff4757;">ç´…æ–¹ (P1)</div>
                <div id="p1-score">0</div>
            </div>
            <div class="score-box">
                <div id="crown-p2" class="crown">ğŸ‘‘</div>
                <div class="player-label" style="color: #2e86de;">è—æ–¹ (P2)</div>
                <div id="p2-score">0</div>
            </div>
        </div>
    </div>
    <div id="board"></div>
</div>

<div id="overlay">
    <div id="result-card">
        <h1 id="win-text">éŠæˆ²çµæŸ</h1>
        <div style="display: flex; gap: 40px; font-size: 2em; margin: 20px 0; justify-content: center;">
            <div style="color: #ff4757;">ç´…: <span id="final-p1">0</span></div>
            <div style="color: #2e86de;">è—: <span id="final-p2">0</span></div>
        </div>
        <button onclick="location.reload()" style="padding: 10px 20px;">å›å¤§å»³</button>
    </div>
</div>

<script>
    const SIZE = 15;
    let board = Array(SIZE).fill().map(() => Array(SIZE).fill(0));
    let connectionsData = [];
    let gameOver = false;
    let peer, conn;
    let myPlayerNum = 0; 
    let currentTurnPlayer = 1;

    // --- GitHub Pages å„ªåŒ–é…ç½® ---
    function initPeer() {
        peer = new Peer(null, {
            host: '0.peerjs.com',
            port: 443,
            secure: true, // å¼·åˆ¶ HTTPS
            path: '/',
            config: {
                'iceServers': [
                    { 'urls': 'stun:stun.l.google.com:19302' },
                    { 'urls': 'stun:stun1.l.google.com:19302' },
                    { 'urls': 'stun:stun2.l.google.com:19302' },
                    { 'urls': 'stun:stun3.l.google.com:19302' }
                ]
            },
            debug: 3
        });

        peer.on('open', (id) => {
            document.getElementById('my-id').innerText = id;
            document.getElementById('status-msg').innerText = "â— ä¼ºæœå™¨å·²å°±ç·’";
        });

        peer.on('connection', (c) => {
            if (conn) {
                c.on('open', () => c.send({type: 'error', msg: 'æˆ¿é–“å·²æ»¿'}));
                setTimeout(() => c.close(), 500);
                return;
            }
            conn = c;
            myPlayerNum = 1;
            setupListeners();
        });

        peer.on('error', (err) => {
            console.error("Peer Error:", err.type);
            const errorLog = document.getElementById('error-log');
            errorLog.style.display = 'block';
            errorLog.innerText = "é€£ç·šéŒ¯èª¤: " + err.type;
            
            if (err.type === 'peer-unavailable') {
                errorLog.innerText += " (æ‰¾ä¸åˆ°å°æ–¹ï¼Œè«‹ç¢ºèª ID æ˜¯å¦æ­£ç¢º)";
            }
        });
    }

    function connectToPeer() {
        const targetId = document.getElementById('peer-id-input').value.trim();
        if (!targetId) return;
        if (targetId === peer.id) return alert("ç„¡æ³•é€£ç·šè‡³è‡ªèº« ID");

        document.getElementById('status-msg').innerText = "â— æ­£åœ¨æ‰“æ´é€£ç·šä¸­...";
        // ä½¿ç”¨ reliable: true åœ¨ GitHub å®‰å…¨ç’°å¢ƒä¸‹è¼ƒç©©å®š
        conn = peer.connect(targetId, { reliable: true });
        myPlayerNum = 2;
        setupListeners();
    }

    function setupListeners() {
        conn.on('open', () => {
            document.getElementById('status-msg').innerText = "â— é€£ç·šæˆåŠŸï¼ŒåŒæ­¥æ•¸æ“šä¸­...";
            // å»¶é²ç™¼é€ Handshakeï¼Œç¢ºä¿é€šé“ç©©å®š
            setTimeout(() => {
                conn.send({ type: 'handshake', from: myPlayerNum });
            }, 300);
        });

        conn.on('data', (data) => {
            if (data.type === 'handshake') {
                startGameUI();
                if (myPlayerNum === 1) conn.send({ type: 'handshake', from: 1 });
            } else if (data.type === 'move') {
                executeTurn(data.r, data.c, data.player);
            }
        });

        conn.on('close', () => {
            alert("å°æ‰‹æ–·é–‹é€£ç·š");
            location.reload();
        });
    }

    // --- æ ¸å¿ƒ UI èˆ‡ æ¸²æŸ“é‚è¼¯ (èˆ‡ç©©å®šç‰ˆä¸€è‡´) ---
    function startGameUI() {
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-container').style.display = 'flex';
        updateTurnDisplay();
        const labels = document.querySelectorAll('.player-label');
        if (myPlayerNum === 1) {
            labels[0].innerText = "æ‚¨ (ç´…æ–¹)";
            labels[1].innerText = "å°æ‰‹ (è—æ–¹)";
        } else {
            labels[0].innerText = "å°æ‰‹ (ç´…æ–¹)";
            labels[1].innerText = "æ‚¨ (è—æ–¹)";
        }
        createBoard();
    }

    function handleMove(r, c) {
        if (gameOver || currentTurnPlayer !== myPlayerNum || !conn || !conn.open) return;
        if (isValidMove(r, c, myPlayerNum)) {
            conn.send({ type: 'move', r, c, player: myPlayerNum });
            executeTurn(r, c, myPlayerNum);
        }
    }

    function executeTurn(r, c, player) {
        board[r][c] = player;
        growLines();
        findNewConnections(r, c, player);
        render();
        updateScore();
        if (!checkGameOver()) {
            currentTurnPlayer = (player === 1) ? 2 : 1;
            updateTurnDisplay();
        }
    }

    function updateTurnDisplay() {
        const display = document.getElementById('turn-display');
        if (currentTurnPlayer === myPlayerNum) {
            display.innerText = "â˜… æ‚¨çš„å›åˆ â˜…";
            display.style.color = "#f1c40f";
        } else {
            display.innerText = "ç­‰å¾…å°æ‰‹è½å­...";
            display.style.color = "#aaa";
        }
    }

    function createBoard() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${r}-${c}`;
                cell.onclick = () => handleMove(r, c);
                boardEl.appendChild(cell);
            }
        }
        render();
    }

    function getLinesAt(r, c) {
        return connectionsData.filter(t => t.path.some(p => p.r === r && p.c === c));
    }

    function isValidMove(r, c, player) {
        if (board[r][c] !== 0) return false;
        const lines = getLinesAt(r, c);
        if (lines.some(l => l.player === (player === 1 ? 2 : 1))) return false;
        return true;
    }

    function findNewConnections(r, c, player) {
        const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
        dirs.forEach(([dr, dc]) => {
            let currR = r + dr, currC = c + dc;
            let found = false;
            while(currR >= 0 && currR < SIZE && currC >= 0 && currC < SIZE) {
                if (board[currR][currC] !== 0) {
                    if (board[currR][currC] === player) found = true;
                    break;
                }
                currR += dr; currC += dc;
            }
            if (found) {
                connectionsData.push({ origin: {r, c}, target: {r: currR, c: currC}, dr, dc, player, path: [], active: true });
            }
        });
    }

    function growLines() {
        connectionsData.forEach(task => {
            if (!task.active) return;
            const last = task.path.length === 0 ? task.origin : task.path[task.path.length - 1];
            const nr = last.r + task.dr, nc = last.c + task.dc;
            if (nr === task.target.r && nc === task.target.c) { task.active = false; return; }
            if (board[nr][nc] !== 0 && board[nr][nc] !== task.player) { task.active = false; return; }
            const currentDir = task.dr !== 0 ? 'v' : 'h';
            if (getLinesAt(nr, nc).some(l => (l.dr !== 0 ? 'v' : 'h') === currentDir)) {
                task.active = false; return;
            }
            task.path.push({r: nr, c: nc});
        });
    }

    function render() {
        for(let r=0; r<SIZE; r++) {
            for(let c=0; c<SIZE; c++) {
                const cell = document.getElementById(`cell-${r}-${c}`);
                if (!cell) continue;
                cell.innerHTML = ''; cell.classList.remove('disputed');
                if (board[r][c] !== 0) {
                    const p = document.createElement('div');
                    p.className = `piece p${board[r][c]}`;
                    cell.appendChild(p);
                }
                const lines = getLinesAt(r, c);
                const hasP1 = lines.some(l => l.player === 1) || board[r][c] === 1;
                const hasP2 = lines.some(l => l.player === 2) || board[r][c] === 2;
                if (hasP1 && hasP2) cell.classList.add('disputed');
                lines.forEach(l => {
                    const lineEl = document.createElement('div');
                    lineEl.className = `line ${l.dr !== 0 ? 'v' : 'h'} p${l.player}`;
                    cell.appendChild(lineEl);
                });
            }
        }
    }

    function updateScore() {
        let p1 = 0, p2 = 0;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const lines = getLinesAt(r, c);
                const hasP1 = board[r][c] === 1 || lines.some(l => l.player === 1);
                const hasP2 = board[r][c] === 2 || lines.some(l => l.player === 2);
                if (hasP1 && hasP2) continue; 
                if (hasP1) p1++; else if (hasP2) p2++;
            }
        }
        document.getElementById('p1-score').innerText = p1;
        document.getElementById('p2-score').innerText = p2;
        return { p1, p2 };
    }

    function checkGameOver() {
        let allOccupied = true;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (board[r][c] === 0 && getLinesAt(r, c).length === 0) { allOccupied = false; break; }
            }
            if (!allOccupied) break;
        }
        if (allOccupied) {
            gameOver = true;
            const s = updateScore();
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('final-p1').innerText = s.p1;
            document.getElementById('final-p2').innerText = s.p2;
            const winText = document.getElementById('win-text');
            if (s.p1 > s.p2) { winText.innerText = "ğŸ‰ ç´…æ–¹ å‹åˆ©ï¼"; document.getElementById('crown-p1').style.display = 'block'; }
            else if (s.p2 > s.p1) { winText.innerText = "ğŸ‰ è—æ–¹ å‹åˆ©ï¼"; document.getElementById('crown-p2').style.display = 'block'; }
            else { winText.innerText = "âš–ï¸ å¹³æ‰‹ï¼"; }
            return true;
        }
        return false;
    }

    function copyMyID() {
        const idText = document.getElementById('my-id').innerText;
        if (idText === "åˆå§‹åŒ–ä¸­...") return;
        navigator.clipboard.writeText(idText).then(() => alert("ID å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼"));
    }

    initPeer();
</script>

</body>
</html>
